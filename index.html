<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nhập Vai Văn Học</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    
    <!-- Custom Styles -->
    <style>
      body {
        font-family: 'Quicksand', sans-serif;
        background-color: #f5f5f4; /* bg-stone-100 */
      }
      .font-serif-display {
        font-family: 'Playfair Display', serif;
      }
      /* Simple bounce animation for typing indicator */
      @keyframes bounce {
        0%, 100% { transform: translateY(-25%); animation-timing-function: cubic-bezier(0.8, 0, 1, 1); }
        50% { transform: translateY(0); animation-timing-function: cubic-bezier(0, 0, 0.2, 1); }
      }
      .animate-bounce { animation: bounce 1s infinite; }
      /* Fade in animation for resume button */
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      .animate-fade-in { animation: fadeIn 1s ease-in-out; }
    </style>
    
    <!-- Import Map for ES Modules -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.3.1",
    "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
    "@google/genai": "https://esm.sh/@google/genai@^1.11.0",
    "react-dom/": "https://esm.sh/react-dom@^19.1.1/",
    "react/": "https://esm.sh/react@^19.1.1/"
  }
}
</script>
    
    <!-- Babel Standalone to transpile JSX/TS in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="react,typescript">
      // Import statements are handled by the importmap
      import React, { useState, useCallback, useMemo, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI, Type } from "@google/genai";

      // --- From types.ts ---
      const GameStatus = {
        ApiKeyEntry: 'ApiKeyEntry',
        WorkSelection: 'WorkSelection',
        WorldCreation: 'WorldCreation',
        Start: 'Start',
        CharacterCreation: 'CharacterCreation',
        Loading: 'Loading',
        Playing: 'Playing',
        Error: 'Error'
      };

      // --- From constants.ts ---
      const GEMINI_MODEL = 'gemini-2.5-flash';

      const baseSystemInstruction = `Bạn là một người kể chuyện bậc thầy cho một game nhập vai tương tác. Người chơi sẽ vào vai một nhân vật trong câu chuyện. Nhiệm vụ của bạn là:
      1. Dựa vào hành động hoặc lời thoại của người chơi (được cung cấp trong prompt), hãy tiếp tục câu chuyện một cách liền mạch và hấp dẫn.
      2. Mô tả kết quả hành động của người chơi, phản ứng của các nhân vật khác, và những thay đổi trong thế giới xung quanh. Giữ cho câu chuyện luôn tiến về phía trước.
      3. Luôn trả lời bằng định dạng JSON theo schema đã cung cấp. Câu trả lời phải là tiếng Việt.
      4. Quan trọng: Hãy tham khảo và sử dụng các thông tin trong 'Sổ tay' (Lorebook) được cung cấp trong lời nhắc hệ thống để đảm bảo tính nhất quán của câu chuyện.`;

      const CHI_PHEO_WORK = {
          id: 'chi-pheo',
          title: 'Chí Phèo',
          author: 'Nam Cao',
          description: 'Sống lại cuộc đời bi kịch của một người nông dân bị tha hóa trong xã hội cũ, và đối mặt với những định kiến tàn nhẫn của làng Vũ Đại.',
          originalCharacterName: 'Chí Phèo',
          originalCharacterDescription: 'Vào vai Chí Phèo, trải nghiệm cuộc đời đầy bi kịch của nhân vật kinh điển trong tác phẩm của Nam Cao.',
          fanficDescription: 'Tạo một nhân vật của riêng bạn và viết nên một câu chuyện hoàn toàn mới trong bối cảnh làng Vũ Đại.',
          initialPromptOriginal: `Bắt đầu câu chuyện. Người chơi đang vào vai Chí Phèo, nhân vật trong tác phẩm cùng tên của nhà văn Nam Cao. Bối cảnh là Chí Phèo vừa ở tù về làng Vũ Đại. Hãy viết đoạn văn mở đầu, mô tả cảnh tượng Chí Phèo bước vào làng trong một buổi trưa hè oi ả, với dáng vẻ say khướt và tâm trạng ngổn ngang.`,
          getFanficInitialPrompt: (character) => {
              return `Bắt đầu một câu chuyện đồng nhân (fanfiction) trong bối cảnh tác phẩm "Chí Phèo" của Nam Cao. Người chơi sẽ vào vai một nhân vật hoàn toàn mới do họ tự tạo ra. Bối cảnh là làng Vũ Đại.

      Thông tin về nhân vật của người chơi:
      - Tên: ${character.name}
      - Ngoại hình: ${character.appearance}
      - Tính cách: ${character.personality}
      - Hoàn cảnh: ${character.background}

      Nhiệm vụ của bạn:
      1. Dựa vào thông tin trên, hãy viết một đoạn văn mở đầu hấp dẫn, giới thiệu nhân vật này và tình huống họ xuất hiện tại làng Vũ Đại. Giữ nguyên không khí và văn phong của Nam Cao.
      2. Tạo ra một tình huống khởi đầu thú vị. Có thể cho họ gặp một nhân vật quen thuộc (như Lý Cường, Bá Kiến, Thị Nở...) hoặc đối mặt với một sự kiện đặc trưng của làng.
      3. Kết thúc đoạn văn mở đầu, sẵn sàng để người chơi đưa ra hành động đầu tiên của họ.`;
          },
          systemInstruction: `${baseSystemInstruction}\nGiọng văn và không khí phải đậm chất của tác phẩm gốc "Chí Phèo".`
      };

      const TRUYEN_KIEU_WORK = {
          id: 'truyen-kieu',
          title: 'Truyện Kiều',
          author: 'Nguyễn Du',
          description: 'Dấn thân vào kiệt tác của Nguyễn Du, theo chân nàng Kiều qua mười lăm năm lưu lạc và đưa ra những lựa chọn định mệnh.',
          originalCharacterName: 'Thúy Kiều',
          originalCharacterDescription: 'Vào vai Thúy Kiều, trải qua những đoạn trường và những lựa chọn định mệnh đã làm nên số phận của nàng.',
          fanficDescription: 'Tạo một nhân vật mới—có thể là một vị quan, một người hầu, hay một nhà buôn—và xem câu chuyện của họ diễn ra như thế nào trong thế giới của Kiều.',
          initialPromptOriginal: `Bắt đầu câu chuyện. Người chơi đang vào vai Thúy Kiều, nhân vật trong "Truyện Kiều" của Nguyễn Du. Bối cảnh là sau khi gia đình gặp đại nạn, Kiều quyết định bán mình chuộc cha và rơi vào tay Mã Giám Sinh. Hãy mô tả cảnh Kiều ở lầu Ngưng Bích, nỗi cô đơn, buồn tủi và tâm trạng ngổn ngang khi nhớ về gia đình và chàng Kim.`,
          getFanficInitialPrompt: (character) => {
              return `Bắt đầu một câu chuyện đồng nhân (fanfiction) trong bối cảnh tác phẩm "Truyện Kiều" của Nguyễn Du. Người chơi sẽ vào vai một nhân vật hoàn toàn mới do họ tự tạo ra.

      Thông tin về nhân vật của người chơi:
      - Tên: ${character.name}
      - Ngoại hình: ${character.appearance}
      - Tính cách: ${character.personality}
      - Hoàn cảnh: ${character.background}

      Nhiệm vụ của bạn:
      1. Dựa vào thông tin trên, viết một đoạn văn mở đầu giới thiệu nhân vật này trong thế giới của Truyện Kiều. Hãy sử dụng văn phong giàu hình ảnh, có thể phảng phất âm hưởng thơ lục bát của Nguyễn Du.
      2. Đặt nhân vật vào một tình huống khởi đầu thú vị, có thể liên quan đến một sự kiện hoặc một nhân vật trong tác phẩm gốc (ví dụ: chứng kiến cảnh Kiều bán mình, gặp gỡ Thúc Sinh, hoặc làm việc cho Hoạn Thư).`;
          },
          systemInstruction: `${baseSystemInstruction}\nSử dụng ngôn ngữ giàu chất thơ, hình ảnh, mang âm hưởng của văn học trung đại và kiệt tác Truyện Kiều.`
      };

      const LITERARY_WORKS = [
          CHI_PHEO_WORK,
          TRUYEN_KIEU_WORK,
      ];

      const createCustomLiteraryWork = (title, author, content) => {
          const customSystemInstruction = `Bạn là một người kể chuyện bậc thầy cho một game nhập vai tương tác. Toàn bộ bối cảnh, nhân vật, và không khí của game được xây dựng dựa trên một văn bản do người dùng cung cấp.

      Văn bản gốc của người dùng:
      ---
      ${content}
      ---

      Nhiệm vụ của bạn là:
      1. Dựa vào hành động hoặc lời thoại của người chơi (được cung cấp trong prompt), tiếp tục câu chuyện một cách liền mạch và hấp dẫn.
      2. Tuyệt đối trung thành với văn bản gốc của người dùng. Sử dụng giọng văn, ngôn ngữ, và không khí được gợi ý từ văn bản đó.
      3. Luôn trả lời bằng định dạng JSON theo schema đã cung cấp. Câu trả lời phải là tiếng Việt.
      4. Quan trọng: Hãy tham khảo và sử dụng các thông tin trong 'Sổ tay' (Lorebook) được cung cấp trong lời nhắc hệ thống để đảm bảo tính nhất quán của câu chuyện.`;

          return {
              id: `custom-${Date.now()}`,
              title: title || "Thế giới Tùy chỉnh",
              author: author || "Người chơi",
              description: `Một thế giới độc đáo được tạo ra dựa trên nội dung bạn cung cấp.`,
              originalCharacterName: '', 
              originalCharacterDescription: '', 
              fanficDescription: 'Tạo một nhân vật để khám phá thế giới bạn vừa tạo ra.',
              initialPromptOriginal: '', 
              content: content,
              getFanficInitialPrompt: (character) => {
                  return `Bắt đầu một câu chuyện trong một thế giới tùy chỉnh do người dùng định nghĩa.

      Bối cảnh thế giới (dựa trên nội dung người dùng cung cấp):
      ---
      ${content}
      ---

      Thông tin về nhân vật của người chơi (một nhân vật mới):
      - Tên: ${character.name}
      - Ngoại hình: ${character.appearance}
      - Tính cách: ${character.personality}
      - Hoàn cảnh: ${character.background}

      Nhiệm vụ của bạn:
      1. Dựa vào thông tin trên, hãy viết một đoạn văn mở đầu hấp dẫn, giới thiệu nhân vật mới này vào bối cảnh thế giới đã cho. Hãy cố gắng nắm bắt và tái hiện văn phong, không khí từ nội dung gốc mà người dùng đã cung cấp.
      2. Tạo ra một tình huống khởi đầu thú vị, phù hợp với thế giới đó.`;
              },
              systemInstruction: customSystemInstruction
          };
      };

      // --- From components/LoadingIndicator.tsx ---
      const LoadingIndicator = () => {
        return (
          <div className="flex flex-col items-center justify-center space-y-4">
            <svg className="animate-spin h-10 w-10 text-stone-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p className="text-stone-600 font-serif-display text-lg italic">Đang tải...</p>
          </div>
        );
      };

      // --- From components/GameScreen.tsx ---
      const TypingIndicator = () => (
          <div className="flex items-center space-x-2">
              <div className="w-2 h-2 bg-stone-500 rounded-full animate-bounce [animation-delay:-0.3s]"></div>
              <div className="w-2 h-2 bg-stone-500 rounded-full animate-bounce [animation-delay:-0.15s]"></div>
              <div className="w-2 h-2 bg-stone-500 rounded-full animate-bounce"></div>
          </div>
      );

      const GameScreen = ({ history, onUserInput, loading, onSaveAndExit, onOpenLorebook, workTitle, onUpdateLastNarrative, onRegenerate, canRegenerate }) => {
        const [input, setInput] = useState('');
        const [editingMessage, setEditingMessage] = useState(null);
        const messagesEndRef = useRef(null);
        const textareaRef = useRef(null);

        const lastModelMessage = history.slice().reverse().find(m => m.role === 'model');

        const scrollToBottom = () => {
          messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
        };
        
        const autoGrowTextarea = () => {
            if (textareaRef.current) {
                textareaRef.current.style.height = 'auto';
                textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
            }
        };

        useEffect(scrollToBottom, [history, loading]);
        useEffect(autoGrowTextarea, [input]);

        const handleFormSubmit = (e) => {
          e.preventDefault();
          if (input.trim() && !loading) {
            onUserInput(input);
            setInput('');
          }
        };
        
        const handleEditClick = () => {
          if (lastModelMessage && !loading) {
            setEditingMessage({ id: lastModelMessage.id, content: lastModelMessage.content });
          }
        };

        const handleSaveEdit = () => {
          if (editingMessage) {
            onUpdateLastNarrative(editingMessage.content);
            setEditingMessage(null);
          }
        };

        const handleCancelEdit = () => {
          setEditingMessage(null);
        };
        
        useEffect(() => {
          if (loading || (lastModelMessage && editingMessage && lastModelMessage.id !== editingMessage.id)) {
            setEditingMessage(null);
          }
        }, [loading, lastModelMessage, editingMessage]);
        
        const handleKeyDown = (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              handleFormSubmit(e);
          }
        };

        return (
        <div className="w-full max-w-4xl mx-auto flex flex-col h-[90vh] bg-white rounded-xl shadow-2xl border border-stone-300">
           <div className="flex-shrink-0 flex justify-between items-center p-4 border-b border-stone-200 bg-stone-50 rounded-t-xl gap-4">
              <h1 className="text-xl font-serif-display text-stone-800 font-bold truncate" title={workTitle}>{workTitle}</h1>
              <div className="flex-shrink-0 flex items-center gap-2">
                <button
                    onClick={onOpenLorebook}
                    className="flex items-center gap-2 bg-white text-stone-800 font-semibold py-2 px-3 rounded-lg shadow-sm border border-stone-300 hover:bg-stone-100 transition-colors text-sm"
                    title="Mở sổ tay"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" /></svg>
                    <span className="hidden sm:inline">Sổ tay</span>
                </button>
                <button
                    onClick={onSaveAndExit}
                    className="bg-stone-700 text-white font-bold py-2 px-3 rounded-lg shadow hover:bg-stone-600 transition-colors text-sm flex items-center gap-2"
                >
                   <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M3 3a1 1 0 011 1v12a1 1 0 11-2 0V4a1 1 0 011-1zm7.707 3.293a1 1 0 010 1.414L9.414 9H17a1 1 0 110 2H9.414l1.293 1.293a1 1 0 01-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                   <span className="hidden sm:inline">Lưu & Thoát</span>
                </button>
              </div>
          </div>
          <div className="flex-grow p-4 md:p-6 overflow-y-auto bg-stone-100 space-y-6">
              {history.map(msg => {
                  const isModel = msg.role === 'model';
                  const isUser = msg.role === 'user';
                  const isBeingEdited = editingMessage?.id === msg.id;
                  return (
                      <div key={msg.id} className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
                          <div className={`max-w-xl w-full flex ${isUser ? 'flex-row-reverse' : 'flex-row'} items-end gap-2 group`}>
                              {isModel && (
                                 <button onClick={handleEditClick} disabled={loading || !!editingMessage} title="Chỉnh sửa" className="opacity-0 group-hover:opacity-100 transition-opacity p-1 text-stone-500 hover:text-stone-800 disabled:opacity-0 mb-1">
                                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                          <path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fillRule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clipRule="evenodd" />
                                      </svg>
                                  </button>
                              )}
                              <div className={`w-full rounded-xl px-4 py-3 shadow-md ${isUser ? 'bg-amber-700 text-white' : 'bg-amber-50 text-stone-800 border border-stone-200'}`}>
                                  {isBeingEdited ? (
                                      <div className="flex flex-col">
                                          <textarea
                                              value={editingMessage.content}
                                              onChange={(e) => setEditingMessage({...editingMessage, content: e.target.value})}
                                              className="w-full p-2 border border-stone-300 rounded-md focus:ring-amber-500 focus:border-amber-500 bg-white text-stone-800 text-base"
                                              rows={Math.min(20, editingMessage.content.split('\n').length + 2)}
                                              autoFocus
                                          />
                                          <div className="flex justify-end gap-2 mt-2">
                                              <button onClick={handleCancelEdit} className="py-1 px-3 rounded text-stone-700 hover:bg-stone-200 text-sm font-semibold">Hủy</button>
                                              <button onClick={handleSaveEdit} className="py-1 px-3 rounded bg-amber-700 text-white hover:bg-amber-600 text-sm font-semibold">Lưu</button>
                                          </div>
                                      </div>
                                  ) : (
                                      <p className={`whitespace-pre-wrap ${isModel ? 'font-serif-display italic leading-relaxed' : ''}`}>
                                        {msg.content}
                                      </p>
                                  )}
                              </div>
                          </div>
                      </div>
                  )
              })}
              {loading && (
                   <div className="flex justify-start">
                       <div className="max-w-xl flex flex-row items-end gap-2">
                           <div className="rounded-xl px-4 py-3 shadow-md bg-amber-50 text-stone-800 border border-stone-200">
                               <TypingIndicator />
                           </div>
                       </div>
                  </div>
              )}
              <div ref={messagesEndRef} />
          </div>
          <div className="flex-shrink-0 p-4 bg-white border-t border-stone-200 rounded-b-xl">
              <div className="flex items-center gap-2">
                  <button
                      onClick={onRegenerate}
                      disabled={loading || !canRegenerate}
                      className="p-2 text-stone-600 hover:bg-stone-200 rounded-full disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                      title="Tạo lại"
                  >
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                          <path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h5M20 20v-5h-5M4 4l1.5 1.5A9 9 0 0120.5 15M20 20l-1.5-1.5A9 9 0 003.5 9" />
                      </svg>
                  </button>
                  <form onSubmit={handleFormSubmit} className="flex-grow flex items-center gap-2">
                      <textarea
                          ref={textareaRef}
                          value={input}
                          onChange={e => setInput(e.target.value)}
                          onKeyDown={handleKeyDown}
                          disabled={loading || !!editingMessage}
                          rows={1}
                          className="w-full px-4 py-2 border border-stone-300 rounded-full focus:ring-amber-500 focus:border-amber-500 resize-none transition-all duration-200 disabled:bg-stone-100"
                          placeholder="Nhập hành động hoặc lời thoại..."
                          style={{maxHeight: '120px'}}
                      />
                      <button 
                          type="submit" 
                          disabled={loading || !input.trim() || !!editingMessage}
                          className="bg-amber-800 text-white rounded-full p-2.5 shadow-lg hover:bg-amber-700 transition-all transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-amber-400 disabled:bg-stone-400 disabled:cursor-not-allowed disabled:transform-none"
                          title="Gửi"
                          >
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                              <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                          </svg>
                      </button>
                  </form>
              </div>
          </div>
        </div>
        );
      };

      // --- From components/LorebookModal.tsx ---
      const LorebookModal = ({ isOpen, onClose, entries, onAdd, onUpdate, onDelete }) => {
        const [isEditing, setIsEditing] = useState(null);
        const [currentKey, setCurrentKey] = useState('');
        const [currentValue, setCurrentValue] = useState('');

        useEffect(() => {
          if (isEditing) {
            setCurrentKey(isEditing.key);
            setCurrentValue(isEditing.value);
          } else {
            setCurrentKey('');
            setCurrentValue('');
          }
        }, [isEditing]);

        if (!isOpen) return null;

        const handleSubmit = (e) => {
          e.preventDefault();
          if (currentKey.trim() === '' || currentValue.trim() === '') return;

          if (isEditing) {
            onUpdate({ ...isEditing, key: currentKey, value: currentValue });
          } else {
            onAdd({ key: currentKey, value: currentValue });
          }
          setIsEditing(null);
        };

        const handleCancelEdit = () => {
          setIsEditing(null);
        };

        return (
          <div className="fixed inset-0 bg-black bg-opacity-60 z-40 flex items-center justify-center p-4" onClick={onClose}>
            <div className="relative bg-stone-50 rounded-xl shadow-2xl border border-stone-300 w-full max-w-2xl max-h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
              <header className="p-6 border-b border-stone-200 flex justify-between items-center">
                <h2 className="text-3xl font-serif-display font-bold text-stone-800">Sổ tay Thế giới</h2>
                <button onClick={onClose} className="text-stone-500 hover:text-stone-800">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
              </header>
              
              <div className="p-6 overflow-y-auto flex-grow">
                {entries.length === 0 && !isEditing ? (
                  <div className="text-center py-12">
                    <p className="text-stone-500">Sổ tay của bạn đang trống.</p>
                    <p className="text-stone-500 mt-1">Thêm một mục mới bên dưới để bắt đầu.</p>
                  </div>
                ) : (
                  <ul className="space-y-3">
                    {entries.map(entry => (
                      <li key={entry.id} className="bg-white p-4 rounded-lg border border-stone-200 shadow-sm flex justify-between items-start">
                        <div>
                          <strong className="text-stone-800 font-bold block">{entry.key}</strong>
                          <p className="text-stone-600 whitespace-pre-wrap">{entry.value}</p>
                        </div>
                        <div className="flex-shrink-0 ml-4 space-x-2">
                          <button onClick={() => setIsEditing(entry)} className="text-amber-700 hover:text-amber-900 font-semibold text-sm">Sửa</button>
                          <button onClick={() => onDelete(entry.id)} className="text-red-600 hover:text-red-800 font-semibold text-sm">Xóa</button>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
              
              <footer className="p-6 border-t border-stone-200 bg-stone-100 rounded-b-xl">
                <h3 className="text-xl font-serif-display font-bold text-stone-700 mb-4">{isEditing ? 'Chỉnh sửa mục' : 'Thêm mục mới'}</h3>
                <form onSubmit={handleSubmit} className="space-y-4">
                  <input
                    type="text"
                    placeholder="Khóa (ví dụ: Nhân vật A, Địa danh B)"
                    value={currentKey}
                    onChange={e => setCurrentKey(e.target.value)}
                    className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500"
                    required
                  />
                  <textarea
                    placeholder="Giá trị (ví dụ: Mô tả chi tiết về nhân vật, địa danh...)"
                    value={currentValue}
                    onChange={e => setCurrentValue(e.target.value)}
                    rows={3}
                    className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500"
                    required
                  />
                  <div className="flex justify-end items-center gap-4">
                    {isEditing && (
                      <button type="button" onClick={handleCancelEdit} className="text-stone-700 font-bold py-2 px-6 rounded-lg hover:bg-stone-200 transition-colors">Hủy</button>
                    )}
                    <button type="submit" className="bg-amber-800 text-white font-bold py-2 px-6 rounded-lg shadow-lg hover:bg-amber-700 transition-transform duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-amber-400">
                      {isEditing ? 'Lưu thay đổi' : 'Thêm vào Sổ tay'}
                    </button>
                  </div>
                </form>
              </footer>
            </div>
          </div>
        );
      };

      // --- Screens and App component from App.tsx ---
      const SAVE_GAME_KEY = 'literary-rpg-save-v4';
      const CHARACTERS_SAVE_KEY = 'literary-rpg-characters';
      const API_KEY_STORAGE_KEY = 'gemini-api-key';

      const ApiKeyScreen = ({ onSubmit, error }) => {
          const [key, setKey] = useState('');
          const handleSubmit = (e) => {
            e.preventDefault();
            if (key.trim()) {
              onSubmit(key.trim());
            }
          };

          return (
            <div className="max-w-md mx-auto p-8 bg-white rounded-xl shadow-2xl border border-stone-300 text-center">
              <h1 className="text-3xl font-serif-display font-bold text-stone-800 mb-4">Nhập API Key</h1>
              <p className="text-stone-600 mb-6">
                Vui lòng nhập khóa API Google Gemini của bạn để bắt đầu. Khóa của bạn sẽ được lưu trữ cục bộ trên trình duyệt.
              </p>
              <form onSubmit={handleSubmit} className="space-y-4">
                <input
                  type="password"
                  value={key}
                  onChange={(e) => setKey(e.target.value)}
                  className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500"
                  placeholder="Google Gemini API Key"
                  required
                />
                {error && <p className="text-red-600 text-sm">{error}</p>}
                <button
                  type="submit"
                  className="w-full bg-amber-800 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-amber-700 transition-transform duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-amber-400"
                >
                  Lưu & Tiếp tục
                </button>
              </form>
               <p className="text-xs text-stone-500 mt-4">
                Bạn có thể lấy API key tại <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="underline hover:text-amber-700">Google AI Studio</a>.
              </p>
            </div>
          );
      };
      
      const WorkSelectionScreen = ({ works, onSelect, onCreateCustom, hasSavedGame, onResume, onChangeApiKey }) => (
          <div className="text-center max-w-5xl mx-auto p-8">
              <h1 className="text-5xl md:text-6xl font-serif-display font-bold text-stone-900 mb-4">Nhập Vai Văn Học</h1>
              <p className="text-stone-600 text-lg mb-10">
                  Chọn một tác phẩm kinh điển, hoặc tạo ra thế giới của riêng bạn.
              </p>

              {hasSavedGame && (
                  <div className="mb-12 animate-fade-in">
                      <button
                          onClick={onResume}
                          className="bg-emerald-700 text-white font-bold py-4 px-10 rounded-lg shadow-lg hover:bg-emerald-600 transition-transform duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-emerald-400 w-full md:w-auto text-xl"
                      >
                          Tiếp tục câu chuyện
                      </button>
                      <p className="text-stone-500 mt-3 text-sm">hoặc bắt đầu một câu chuyện mới bên dưới</p>
                  </div>
              )}

              <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
                  {works.map(work => (
                      <div 
                          key={work.id}
                          className="bg-white rounded-xl shadow-2xl border border-stone-300 overflow-hidden flex flex-col group cursor-pointer transform hover:-translate-y-2 transition-transform duration-300"
                          onClick={() => onSelect(work)}
                      >
                          <div className="p-8 text-left flex-grow">
                              <h2 className="text-3xl font-serif-display font-bold text-stone-800 mb-2">{work.title}</h2>
                              <p className="text-stone-500 font-semibold mb-4">Tác giả: {work.author}</p>
                              <p className="text-stone-600">{work.description}</p>
                          </div>
                          <div className="bg-stone-800 text-amber-50 font-bold py-3 px-8 group-hover:bg-amber-800 transition-colors duration-300 text-center">
                              Khám phá
                          </div>
                      </div>
                  ))}
                  <div 
                      key="custom-world"
                      className="bg-amber-50 rounded-xl shadow-2xl border border-amber-300 overflow-hidden flex flex-col group cursor-pointer transform hover:-translate-y-2 transition-transform duration-300"
                      onClick={onCreateCustom}
                  >
                      <div className="p-8 text-center flex-grow flex flex-col items-center justify-center">
                           <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 text-amber-800 group-hover:text-amber-700 transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
                              <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                          </svg>
                          <h2 className="text-3xl font-serif-display font-bold text-amber-900 mt-4">Tạo Thế Giới Mới</h2>
                          <p className="text-amber-800 mt-2">Nhập vào tác phẩm, tóm tắt, hoặc ý tưởng của bạn.</p>
                      </div>
                      <div className="bg-amber-800 text-white font-bold py-3 px-8 group-hover:bg-amber-700 transition-colors duration-300 text-center">
                          Bắt đầu sáng tạo
                      </div>
                  </div>
              </div>
               <div className="mt-12 text-center">
                  <button
                    onClick={onChangeApiKey}
                    className="text-stone-500 hover:text-stone-800 underline text-sm font-semibold"
                  >
                    Thay đổi API Key
                  </button>
                </div>
          </div>
      );

      const WorldCreatorScreen = ({ onSubmit, onBack }) => {
          const [worldData, setWorldData] = useState({ title: '', author: '', content: '' });
          const handleChange = (e) => setWorldData({ ...worldData, [e.target.name]: e.target.value });
          const isFormValid = useMemo(() => worldData.content.trim().length > 50, [worldData]);
          const handleSubmit = (e) => { e.preventDefault(); if (isFormValid) onSubmit(worldData); };

          return (
              <div className="max-w-3xl mx-auto p-8 bg-white rounded-xl shadow-2xl border border-stone-300">
                  <h1 className="text-4xl font-serif-display font-bold text-stone-800 mb-6 text-center">Tạo Thế Giới Mới</h1>
                  <p className="text-stone-600 mb-8 text-center">Cung cấp nội dung để AI xây dựng thế giới, nhân vật và văn phong cho câu chuyện của bạn.</p>
                  <form onSubmit={handleSubmit} className="space-y-6">
                       <div>
                          <label htmlFor="title" className="block text-sm font-bold text-stone-700 mb-2">Tên tác phẩm (Tùy chọn)</label>
                          <input type="text" id="title" name="title" value={worldData.title} onChange={handleChange} className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500" placeholder="Ví dụ: Số Đỏ, Lão Hạc, Harry Potter..."/>
                      </div>
                       <div>
                          <label htmlFor="author" className="block text-sm font-bold text-stone-700 mb-2">Tác giả (Tùy chọn)</label>
                          <input type="text" id="author" name="author" value={worldData.author} onChange={handleChange} className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500" placeholder="Ví dụ: Vũ Trọng Phụng, Nam Cao..."/>
                      </div>
                      <div>
                          <label htmlFor="content" className="block text-sm font-bold text-stone-700 mb-2">Nội dung, tóm tắt, hoặc trích đoạn</label>
                          <textarea id="content" name="content" value={worldData.content} onChange={handleChange} rows={10} className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500" placeholder="Dán nội dung vào đây. Nội dung càng chi tiết, AI sẽ tạo ra thế giới càng sâu sắc và đúng với văn phong gốc. (Yêu cầu tối thiểu 50 ký tự)" required />
                          {!isFormValid && worldData.content.trim() !== '' && <p className="text-sm text-red-600 mt-1">Nội dung cần dài hơn để AI có thể hiểu được bối cảnh.</p>}
                      </div>
                      <div className="flex items-center justify-between pt-4">
                          <button type="button" onClick={onBack} className="text-stone-700 font-bold py-3 px-8 rounded-lg hover:bg-stone-200 transition-colors">Quay lại</button>
                          <button type="submit" disabled={!isFormValid} className="bg-amber-800 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-amber-700 transition-transform duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-amber-400 disabled:bg-stone-400 disabled:cursor-not-allowed disabled:transform-none">Tạo thế giới & Viết truyện</button>
                      </div>
                  </form>
              </div>
          );
      };

      const ModeSelectionScreen = ({ work, onStartAsOriginal, onStartFanfic, onBack }) => (
        <div className="relative text-center max-w-4xl mx-auto p-8 bg-white rounded-xl shadow-2xl border border-stone-300">
          <button onClick={onBack} className="absolute top-4 left-4 text-stone-600 hover:text-stone-900 font-bold py-2 px-4 transition-colors">
              &larr; Chọn lại tác phẩm
          </button>
          <h1 className="text-5xl md:text-6xl font-serif-display font-bold text-stone-800 mb-2">{work.title}</h1>
          <p className="text-stone-600 text-lg mb-8">
              Mỗi lựa chọn của bạn sẽ viết nên một trang truyện khác biệt trong thế giới của {work.author}.
          </p>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="border border-stone-300 rounded-lg p-6 flex flex-col items-center bg-stone-50">
              <h2 className="text-2xl font-serif-display font-bold text-stone-800 mb-2">{work.originalCharacterName}</h2>
              <p className="text-stone-600 mb-4 flex-grow">{work.originalCharacterDescription}</p>
              <button
                onClick={onStartAsOriginal}
                className="bg-stone-800 text-amber-50 font-bold py-3 px-10 rounded-lg shadow-lg hover:bg-stone-700 transition-transform duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-stone-400 w-full"
              >
                Vào vai {work.originalCharacterName}
              </button>
            </div>
            <div className="border border-stone-300 rounded-lg p-6 flex flex-col items-center bg-stone-50">
              <h2 className="text-2xl font-serif-display font-bold text-stone-800 mb-2">Đồng nhân</h2>
              <p className="text-stone-600 mb-4 flex-grow">{work.fanficDescription}</p>
              <button
                onClick={onStartFanfic}
                className="bg-amber-800 text-white font-bold py-3 px-10 rounded-lg shadow-lg hover:bg-amber-700 transition-transform duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-amber-400 w-full"
              >
                Tạo nhân vật mới
              </button>
            </div>
          </div>
        </div>
      );

      const CharacterCreationScreen = ({ work, onSubmit, onBack, savedCharacters, onSaveCharacter }) => {
        const [character, setCharacter] = useState({ name: '', appearance: '', personality: '', background: '' });
        const [shouldSave, setShouldSave] = useState(true);

        const handleChange = (e) => setCharacter({ ...character, [e.target.name]: e.target.value });
        
        const isFormValid = useMemo(() => (
          character.name.trim() !== '' &&
          character.appearance.trim() !== '' &&
          character.personality.trim() !== '' &&
          character.background.trim() !== ''
        ), [character]);

        const handleSubmit = (e) => {
          e.preventDefault();
          if (!isFormValid) return;
          const finalCharacter = { ...character, id: `char-ingame-${Date.now()}` };
          if (shouldSave) {
            onSaveCharacter(character);
          }
          onSubmit(finalCharacter);
        };

        const handleSelectCharacter = (e) => {
          const selectedId = e.target.value;
          if (!selectedId) {
            setCharacter({ name: '', appearance: '', personality: '', background: '' });
            return;
          }
          const selectedChar = savedCharacters.find(c => c.id === selectedId);
          if (selectedChar) {
            const { id, ...charData } = selectedChar;
            setCharacter(charData);
          }
        };

        return (
          <div className="max-w-2xl mx-auto p-8 bg-white rounded-xl shadow-2xl border border-stone-300">
            <h1 className="text-4xl font-serif-display font-bold text-stone-800 mb-6 text-center">Tạo Nhân Vật Mới</h1>
            <p className="text-stone-600 mb-8 text-center">Hãy thổi hồn cho nhân vật của bạn để bắt đầu một câu chuyện mới trong thế giới của <span className="font-bold">{work.title}</span>.</p>
            
            {savedCharacters.length > 0 && (
              <div className="mb-8">
                <label htmlFor="character-select" className="block text-sm font-bold text-stone-700 mb-2">Hoặc chọn nhân vật đã có</label>
                <select
                  id="character-select"
                  onChange={handleSelectCharacter}
                  className="w-full px-4 py-3 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500 bg-white shadow-sm"
                >
                  <option value="">-- Tạo một nhân vật mới --</option>
                  {savedCharacters.map(char => (
                    <option key={char.id} value={char.id}>{char.name}</option>
                  ))}
                </select>
              </div>
            )}

            <form onSubmit={handleSubmit} className="space-y-6">
              <div>
                <label htmlFor="name" className="block text-sm font-bold text-stone-700 mb-2">Tên nhân vật</label>
                <input type="text" id="name" name="name" value={character.name} onChange={handleChange} className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500" placeholder="Ví dụ: Anh Ba Gánh Nước" required />
              </div>
              <div>
                <label htmlFor="appearance" className="block text-sm font-bold text-stone-700 mb-2">Ngoại hình</label>
                <textarea id="appearance" name="appearance" value={character.appearance} onChange={handleChange} rows={3} className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500" placeholder="Ví dụ: Thân hình gầy gò, nước da ngăm đen..." required />
              </div>
              <div>
                <label htmlFor="personality" className="block text-sm font-bold text-stone-700 mb-2">Tính cách</label>
                <textarea id="personality" name="personality" value={character.personality} onChange={handleChange} rows={3} className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500" placeholder="Ví dụ: Hiền lành, ít nói nhưng quật cường..." required />
              </div>
              <div>
                <label htmlFor="background" className="block text-sm font-bold text-stone-700 mb-2">Hoàn cảnh</label>
                <textarea id="background" name="background" value={character.background} onChange={handleChange} rows={4} className="w-full px-4 py-2 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500" placeholder="Ví dụ: Một thầy lang trẻ từ nơi khác đến..." required />
              </div>
              
              <div className="flex items-center gap-3 pt-2">
                  <input 
                      type="checkbox" 
                      id="saveCharacter" 
                      name="saveCharacter" 
                      checked={shouldSave} 
                      onChange={(e) => setShouldSave(e.target.checked)}
                      className="h-5 w-5 rounded border-gray-300 text-amber-600 focus:ring-amber-500"
                  />
                  <label htmlFor="saveCharacter" className="text-sm text-stone-700 font-medium">Lưu nhân vật này để sử dụng lại</label>
              </div>

              <div className="flex items-center justify-between pt-4">
                 <button type="button" onClick={onBack} className="text-stone-700 font-bold py-3 px-8 rounded-lg hover:bg-stone-200 transition-colors">Quay lại</button>
                <button type="submit" disabled={!isFormValid} className="bg-amber-800 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-amber-700 transition-transform duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-amber-400 disabled:bg-stone-400 disabled:cursor-not-allowed disabled:transform-none">Bắt đầu câu chuyện</button>
              </div>
            </form>
          </div>
        );
      };

      const App = () => {
        const [status, setStatus] = useState(GameStatus.Loading);
        const [ai, setAi] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        const [selectedWork, setSelectedWork] = useState(null);
        const [history, setHistory] = useState([]);
        const [lastPrompt, setLastPrompt] = useState(null);
        const [error, setError] = useState(null);
        const [hasSavedGame, setHasSavedGame] = useState(false);
        const [savedCharacters, setSavedCharacters] = useState([]);
        const [lorebook, setLorebook] = useState([]);
        const [isLorebookOpen, setIsLorebookOpen] = useState(false);

        useEffect(() => {
          try {
            const savedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (savedKey) {
                setAi(new GoogleGenAI({ apiKey: savedKey }));
                const savedData = localStorage.getItem(SAVE_GAME_KEY);
                if (savedData) setHasSavedGame(true);
                
                const savedChars = localStorage.getItem(CHARACTERS_SAVE_KEY);
                if (savedChars) setSavedCharacters(JSON.parse(savedChars));

                setStatus(GameStatus.WorkSelection);
            } else {
                setStatus(GameStatus.ApiKeyEntry);
            }
          } catch (e) {
              console.error("Lỗi khởi tạo:", e);
              localStorage.removeItem(API_KEY_STORAGE_KEY);
              setStatus(GameStatus.ApiKeyEntry);
          }
        }, []);

        const generateStorySegment = useCallback(async (prompt, systemInstruction, lorebook = []) => {
            if (!ai) {
              throw new Error("Ứng dụng chưa được khởi tạo với API Key.");
            }
            try {
              const responseSchema = {
                  type: Type.OBJECT,
                  properties: {
                      narrative: {
                          type: Type.STRING,
                          description: "Phần tường thuật câu chuyện, mô tả bối cảnh, sự kiện và cảm xúc nhân vật, tiếp nối hành động trước đó của người chơi. Viết bằng giọng văn phù hợp với tác phẩm được chọn.",
                      },
                  },
                  required: ["narrative"],
              };

              let finalSystemInstruction = systemInstruction;
              if (lorebook.length > 0) {
                const lorebookContext = lorebook.map(entry => `- ${entry.key}: ${entry.value}`).join('\n');
                finalSystemInstruction += `\n\n--- SỔ TAY (LOREBOOK) ---\n${lorebookContext}\n--- KẾT THÚC SỔ TAY ---`;
              }
    
              const response = await ai.models.generateContent({
                model: GEMINI_MODEL,
                contents: prompt,
                config: {
                  systemInstruction: finalSystemInstruction,
                  responseMimeType: "application/json",
                  responseSchema: responseSchema,
                  thinkingConfig: { thinkingBudget: 0 } 
                },
              });
    
              const jsonText = response.text.trim();
              const cleanedJsonText = jsonText.replace(/^```json\s*|```$/g, '');
              const parsedResponse = JSON.parse(cleanedJsonText);
    
              if (!parsedResponse.narrative) {
                  throw new Error("Phản hồi từ AI không hợp lệ.");
              }
              
              return { narrative: parsedResponse.narrative, choices: [] };
    
            } catch (error) {
              console.error("Lỗi khi gọi Gemini API:", error);
              if (error.message && (error.message.includes("API key not valid") || error.message.includes("invalid"))) {
                 throw new Error("API key không hợp lệ. Vui lòng kiểm tra và điền lại key chính xác.");
              }
              throw new Error("Không thể tạo tiếp diễn biến câu chuyện. Vui lòng thử lại.");
            }
        }, [ai]);


        const startStory = useCallback(async (initialPrompt, systemInstruction) => {
          setIsLoading(true);
          setError(null);
          setLastPrompt(initialPrompt);
          try {
            const firstSegment = await generateStorySegment(initialPrompt, systemInstruction, lorebook);
            setHistory([{ role: 'model', content: firstSegment.narrative, id: `model-${Date.now()}` }]);
            setStatus(GameStatus.Playing);
          } catch (e) {
            setError(e instanceof Error ? e.message : "Đã xảy ra lỗi không xác định.");
            setStatus(GameStatus.Error);
          } finally {
            setIsLoading(false);
          }
        }, [lorebook, generateStorySegment]);
        
        const handleUserInput = useCallback(async (userInput) => {
          if (!selectedWork) return;
          
          const newUserMessage = { role: 'user', content: userInput, id: `user-${Date.now()}`};
          setHistory(prev => [...prev, newUserMessage]);
          setLastPrompt(userInput);
          setIsLoading(true);
          setError(null);
          
          try {
            const nextSegment = await generateStorySegment(userInput, selectedWork.systemInstruction, lorebook);
            const newModelMessage = { role: 'model', content: nextSegment.narrative, id: `model-${Date.now()}` };
            setHistory(prev => [...prev, newModelMessage]);
          } catch (e) {
            setError(e instanceof Error ? e.message : "Đã xảy ra lỗi không xác định.");
            setStatus(GameStatus.Error);
          } finally {
              setIsLoading(false);
          }
        }, [selectedWork, lorebook, generateStorySegment]);

        const handleRegenerate = useCallback(async () => {
            if (!selectedWork || !lastPrompt || isLoading) return;
            
            setHistory(prev => {
                const last = prev[prev.length -1];
                if(last && last.role === 'model') return prev.slice(0, -1);
                return prev;
            });

            setIsLoading(true);
            setError(null);
            try {
                const nextSegment = await generateStorySegment(lastPrompt, selectedWork.systemInstruction, lorebook);
                const newModelMessage = { role: 'model', content: nextSegment.narrative, id: `model-${Date.now()}` };
                setHistory(prev => [...prev, newModelMessage]);
            } catch (e) {
                setError(e instanceof Error ? e.message : "Đã xảy ra lỗi không xác định.");
                setStatus(GameStatus.Error);
            } finally {
                setIsLoading(false);
            }
        }, [selectedWork, lastPrompt, lorebook, isLoading, generateStorySegment]);
        
        const handleUpdateLastNarrative = (newContent) => {
            setHistory(prev => {
              const newHistory = [...prev];
              const lastMessageIndex = newHistory.length -1;
              if(lastMessageIndex >= 0 && newHistory[lastMessageIndex].role === 'model'){
                  newHistory[lastMessageIndex] = { ...newHistory[lastMessageIndex], content: newContent };
                  return newHistory;
              }
              return prev;
            });
        };

        const handleApiKeySubmit = (key) => {
            try {
                const newAi = new GoogleGenAI({ apiKey: key });
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                setAi(newAi);
                setStatus(GameStatus.WorkSelection);
                setError(null);
            } catch (e) {
                console.error("Lỗi khởi tạo API key:", e);
                setError("Khóa API không hợp lệ. Vui lòng thử lại.");
            }
        };

        const handleChangeApiKey = () => {
            if (window.confirm("Bạn có muốn thay đổi API Key? Hành động này sẽ đưa bạn về màn hình chính.")) {
                localStorage.removeItem(API_KEY_STORAGE_KEY);
                localStorage.removeItem(SAVE_GAME_KEY); // Also clear save game
                setAi(null);
                setHistory([]);
                setSelectedWork(null);
                setHasSavedGame(false);
                setStatus(GameStatus.ApiKeyEntry);
                setError(null);
            }
        };

        const handleStartNewGame = (startAction) => {
          if (hasSavedGame) {
              if (window.confirm("Bạn có chắc muốn bắt đầu một câu chuyện mới? Tiến trình hiện tại sẽ bị xóa.")) {
                  localStorage.removeItem(SAVE_GAME_KEY);
                  setHasSavedGame(false);
                  setLorebook([]);
                  setLastPrompt(null);
                  setHistory([]);
                  startAction();
              }
          } else {
              setLorebook([]);
              setLastPrompt(null);
              setHistory([]);
              startAction();
          }
        };

        const handleSelectWork = (work) => {
          handleStartNewGame(() => {
              setSelectedWork(work);
              setStatus(GameStatus.Start);
          });
        };

        const handleStartOriginal = () => {
          if (selectedWork) {
              startStory(selectedWork.initialPromptOriginal, selectedWork.systemInstruction);
          }
        };
        
        const handleStartFanfic = (character) => {
          if (selectedWork) {
              const prompt = selectedWork.getFanficInitialPrompt(character);
              startStory(prompt, selectedWork.systemInstruction);
          }
        };

        const handleSaveCharacter = (characterToSave) => {
          setSavedCharacters(prevChars => {
              const newChar = { ...characterToSave, id: `char-lib-${Date.now()}`};
              const newCharsList = [...prevChars, newChar];
              localStorage.setItem(CHARACTERS_SAVE_KEY, JSON.stringify(newCharsList));
              return newCharsList;
          });
        };

        const handleStartCharacterCreation = () => setStatus(GameStatus.CharacterCreation);

        const handleStartWorldCreation = () => {
          handleStartNewGame(() => {
              setStatus(GameStatus.WorldCreation);
              setSelectedWork(null);
          });
        };
        
        const handleCreateCustomWork = (data) => {
          const customWork = createCustomLiteraryWork(data.title, data.author, data.content);
          setSelectedWork(customWork);
          setStatus(GameStatus.CharacterCreation);
        };
        
        const resetToWorkSelection = (clearSave = true) => {
          if (clearSave) {
              localStorage.removeItem(SAVE_GAME_KEY);
              setHasSavedGame(false);
          }
          setStatus(GameStatus.WorkSelection);
          setSelectedWork(null);
          setHistory([]);
          setError(null);
          setLorebook([]);
          setLastPrompt(null);
        }

        const resetToModeSelection = () => {
          if(selectedWork && selectedWork.id.startsWith('custom-')) {
              setStatus(GameStatus.WorldCreation);
          } else {
              setStatus(GameStatus.Start);
          }
          setHistory([]);
          setError(null);
        }

        const handleSaveAndExit = () => {
          if (status === GameStatus.Playing && selectedWork && history.length > 0) {
              const stateToSave = {
                  version: 'v4',
                  selectedWork,
                  history,
                  lorebook,
                  lastPrompt,
              };
              localStorage.setItem(SAVE_GAME_KEY, JSON.stringify(stateToSave));
              setHasSavedGame(true);
          }
          resetToWorkSelection(false);
        };

        const handleResumeGame = () => {
          const savedData = localStorage.getItem(SAVE_GAME_KEY);
          if (!savedData) return;

          try {
              const { version, selectedWork: savedWork, history: savedHistory, lorebook: savedLorebook, lastPrompt: savedLastPrompt } = JSON.parse(savedData);
              if(version !== 'v4'){
                  resetToWorkSelection(true);
                  alert("Phiên bản lưu cũ không tương thích. Bắt đầu trò chơi mới.");
                  return;
              }

              let workInstance;
              if (savedWork.id.startsWith('custom-')) {
                  workInstance = createCustomLiteraryWork(savedWork.title, savedWork.author, savedWork.content || '');
                  workInstance.id = savedWork.id; 
              } else {
                  const foundWork = LITERARY_WORKS.find(w => w.id === savedWork.id);
                  if (!foundWork) throw new Error("Could not find saved work.");
                  workInstance = foundWork;
              }

              setSelectedWork(workInstance);
              setHistory(savedHistory || []);
              setLorebook(savedLorebook || []);
              setLastPrompt(savedLastPrompt || null);
              setStatus(GameStatus.Playing);

          } catch (e) {
              console.error("Failed to load game:", e);
              resetToWorkSelection(true);
          }
        };

        const handleAddLoreEntry = (entry) => {
          setLorebook(prev => [...prev, { ...entry, id: `lore-${Date.now()}` }]);
        };
        const handleUpdateLoreEntry = (updatedEntry) => {
          setLorebook(prev => prev.map(e => e.id === updatedEntry.id ? updatedEntry : e));
        };
        const handleDeleteLoreEntry = (id) => {
          setLorebook(prev => prev.filter(e => e.id !== id));
        };

        const renderContent = () => {
          switch (status) {
            case GameStatus.ApiKeyEntry:
              return <ApiKeyScreen onSubmit={handleApiKeySubmit} error={error} />;
            case GameStatus.WorkSelection:
              return <WorkSelectionScreen works={LITERARY_WORKS} onSelect={handleSelectWork} onCreateCustom={handleStartWorldCreation} hasSavedGame={hasSavedGame} onResume={handleResumeGame} onChangeApiKey={handleChangeApiKey} />;
            case GameStatus.WorldCreation:
              return <WorldCreatorScreen onSubmit={handleCreateCustomWork} onBack={() => resetToWorkSelection(false)} />;
            case GameStatus.Start:
              return selectedWork && <ModeSelectionScreen work={selectedWork} onStartAsOriginal={handleStartOriginal} onStartFanfic={handleStartCharacterCreation} onBack={() => resetToWorkSelection(false)} />;
            case GameStatus.CharacterCreation:
              return selectedWork && <CharacterCreationScreen work={selectedWork} onSubmit={handleStartFanfic} onBack={resetToModeSelection} savedCharacters={savedCharacters} onSaveCharacter={handleSaveCharacter} />;
            case GameStatus.Playing:
              return selectedWork && <GameScreen history={history} onUserInput={handleUserInput} loading={isLoading} onSaveAndExit={handleSaveAndExit} onOpenLorebook={() => setIsLorebookOpen(true)} workTitle={selectedWork.title} onUpdateLastNarrative={handleUpdateLastNarrative} onRegenerate={handleRegenerate} canRegenerate={!!lastPrompt} />;
            case GameStatus.Error:
              const isApiKeyError = error && (error.includes("API key") || error.includes("API Key"));
              return (
                <div className="text-center max-w-xl mx-auto p-8 bg-red-50 rounded-xl shadow-lg border border-red-300">
                  <h2 className="text-3xl font-serif-display font-bold text-red-800 mb-4">Ôi, có lỗi rồi!</h2>
                  <p className="text-red-700 mb-6">{error}</p>
                  <button
                    onClick={() => isApiKeyError ? handleChangeApiKey() : resetToWorkSelection(true)}
                    className="bg-red-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-red-600 transition-colors duration-300"
                  >
                    {isApiKeyError ? "Nhập lại API Key" : "Thử lại từ đầu"}
                  </button>
                </div>
              );
            default:
              return <LoadingIndicator />;
          }
        };

        return (
          <div className="min-h-screen w-full text-stone-900 flex items-center justify-center p-4">
            <main className="relative z-10 w-full">
              {renderContent()}
            </main>
            <LorebookModal 
              isOpen={isLorebookOpen}
              onClose={() => setIsLorebookOpen(false)}
              entries={lorebook}
              onAdd={handleAddLoreEntry}
              onUpdate={handleUpdateLoreEntry}
              onDelete={handleDeleteLoreEntry}
            />
          </div>
        );
      };

      // --- From index.tsx: Final Render Call ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Không tìm thấy phần tử gốc để gắn kết ứng dụng");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>